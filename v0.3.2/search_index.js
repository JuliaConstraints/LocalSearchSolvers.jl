var documenterSearchIndex = {"docs":
[{"location":"sudoku/#Sudoku","page":"Sudoku","title":"Sudoku","text":"","category":"section"},{"location":"sudoku/","page":"Sudoku","title":"Sudoku","text":"From Wikipedia's English page.","category":"page"},{"location":"sudoku/","page":"Sudoku","title":"Sudoku","text":"Sudoku is a logic-based, combinatorial number-placement puzzle. In classic sudoku, the objective is to fill a 9×9 grid with digits so that each column, each row, and each of the nine 3×3 subgrids that compose the grid contain all of the digits from 1 to 9. The puzzle setter provides a partially completed grid, which for a well-posed puzzle has a single solution.","category":"page"},{"location":"sudoku/","page":"Sudoku","title":"Sudoku","text":"Each column, row, and region of the sudoku grid can only have a number from each of 1 to 9.","category":"page"},{"location":"sudoku/","page":"Sudoku","title":"Sudoku","text":"For instance, given this initial grid:","category":"page"},{"location":"sudoku/","page":"Sudoku","title":"Sudoku","text":"<img src=\"https://upload.wikimedia.org/wikipedia/commons/f/ff/Sudoku-by-L2G-20050714.svg\" width=\"256\" height=\"256\">","category":"page"},{"location":"sudoku/","page":"Sudoku","title":"Sudoku","text":"The final state (i.e. solution) must be:","category":"page"},{"location":"sudoku/","page":"Sudoku","title":"Sudoku","text":"<img src=\"https://upload.wikimedia.org/wikipedia/commons/c/ce/Sudokusolution1.svg\" width=\"256\" height=\"256\">","category":"page"},{"location":"sudoku/#Constructing-a-sudoku-model","page":"Sudoku","title":"Constructing a sudoku model","text":"","category":"section"},{"location":"sudoku/","page":"Sudoku","title":"Sudoku","text":"ConstraintModels.sudoku","category":"page"},{"location":"sudoku/#ConstraintModels.sudoku","page":"Sudoku","title":"ConstraintModels.sudoku","text":"sudoku(n; start= Dictionary{Int, Int}(), modeler = :JuMP)\n\nCreate a model for the sudoku problem of domain 1:n² with optional starting values. The modeler argument accepts :raw, :MOI, and :JuMP (default), which refer respectively to the solver internal model, the MathOptInterface model, and the JuMP model.\n\n# Construct a JuMP model `m` and its associated matrix `grid` for sudoku 9×9\nm, grid = sudoku(3)\n\n# Same with a starting instance\ninstance = [\n    9  3  0  0  0  0  0  4  0\n    0  0  0  0  4  2  0  9  0\n    8  0  0  1  9  6  7  0  0\n    0  0  0  4  7  0  0  0  0\n    0  2  0  0  0  0  0  6  0\n    0  0  0  0  2  3  0  0  0\n    0  0  8  5  3  1  0  0  2\n    0  9  0  2  8  0  0  0  0\n    0  7  0  0  0  0  0  5  3\n]\nm, grid = sudoku(3, start = instance)\n\n# Run the solver\noptimize!(m)\n\n# Retrieve and display the values\nsolution = value.(grid)\ndisplay(solution, Val(:sudoku))\n\n\n\n\n\n","category":"function"},{"location":"sudoku/#Detailed-implementation","page":"Sudoku","title":"Detailed implementation","text":"","category":"section"},{"location":"sudoku/","page":"Sudoku","title":"Sudoku","text":"To start modeling with Sudoku with the solver,  we will use JuMP.jl syntax.","category":"page"},{"location":"sudoku/","page":"Sudoku","title":"Sudoku","text":"First, create a model with JuMP.Model(CBLS.Optimizer). Given n = 3 the grid will be of size n^2 by n^2 (i.e. 9×9)","category":"page"},{"location":"sudoku/","page":"Sudoku","title":"Sudoku","text":"using CBLS # the JuMP interface of LocalSearchSolvers.jl\nusing JuMP\n\nN = n^2\nmodel = JuMP.Model(CBLS.Optimizer)","category":"page"},{"location":"sudoku/","page":"Sudoku","title":"Sudoku","text":"Create a matrix of variables, where each variable represents a cell of the Sudoku, this means that every variable must be an integer between 1 and 9.","category":"page"},{"location":"sudoku/","page":"Sudoku","title":"Sudoku","text":"(If initial values are provided, the variables representing the known values take will be constant variables, and the rest of the unknown variables are initialized as integers between 1 and 9)","category":"page"},{"location":"sudoku/","page":"Sudoku","title":"Sudoku","text":"# Create and initialize variables.\nif isnothing(start) # If no initial configuration is provided\n    @variable(m, X[1:N, 1:N], DiscreteSet(1:N)) # Create a matrix of N*N variables with values from 1 to N\nelse\n    @variable(m, X[1:N, 1:N]) # Create a matrix of N*N variables with no value taken yet\n    for i in 1:N, j in 1:N # Iterate through the matrix\n        v_ij = start[i,j] # Retrieve the value of the current cell\n        if 1 ≤ v_ij ≤ N # If the value of the current cell is a number between 1 and N (i.e. already provided by the initial configuration)\n        # Create a constraint forcing the variable representing the current cell to be a constant equal to the value provided by the initial configuration\n            @constraint(m, X[i,j] in DiscreteSet(v_ij))\n        else\n            @constraint(m, X[i,j] in DiscreteSet(1:N)) # Else create a constraint stating that the variable must be between 1 and N\n        end\n    end\nend","category":"page"},{"location":"sudoku/","page":"Sudoku","title":"Sudoku","text":"Define the rows, columns and block constraints. The solver has a Global Constraint AllDifferent() stating that a set of variables must have different values.","category":"page"},{"location":"sudoku/","page":"Sudoku","title":"Sudoku","text":"for i in 1:N\n    @constraint(m, X[i,:] in AllDifferent()) # All variables on the same row must be different\n    @constraint(m, X[:,i] in AllDifferent()) # All variables on the same column must be different\nend\nfor i in 0:(n-1), j in 0:(n-1)\n    @constraint(m, vec(X[(i*n+1):(n*(i+1)), (j*n+1):(n*(j+1))]) in AllDifferent()) # All variables on the same block must be different\nend\n ```\n\n* Finally, solve model using the `optimize!()` function with the model in arguments *\n ```julia\n# Run the solver\noptimize!(m)","category":"page"},{"location":"sudoku/","page":"Sudoku","title":"Sudoku","text":"After model is solved, use value.(grid) to get the final value of all variables on the grid matrix, and display the solution using the display() function","category":"page"},{"location":"sudoku/","page":"Sudoku","title":"Sudoku","text":"# Retrieve and display the values\nsolution = value.(grid)\ndisplay(solution, Val(:sudoku))","category":"page"},{"location":"d_constraint/#Constraints.jl","page":"Constraints.jl","title":"Constraints.jl","text":"","category":"section"},{"location":"d_constraint/","page":"Constraints.jl","title":"Constraints.jl","text":"A  back-end package for JuliaConstraints front packages, such as LocalSearchSolvers.jl.","category":"page"},{"location":"d_constraint/","page":"Constraints.jl","title":"Constraints.jl","text":"It provides the following features:","category":"page"},{"location":"d_constraint/","page":"Constraints.jl","title":"Constraints.jl","text":"A dictionary to store usual constraint: usual_constraint, which contains the following entries\n:all_different\n:dist_different\n:eq, :all_equal, :all_equal_param\n:ordered\n:always_true (mainly for testing default Constraint() constructor)\nFor each constraint c, the following properties\narguments length\nconcept (predicate the variables compliance with c)\nerror (a function that evaluate how much c is violated)\nparameters length\nknown symmetries of c\nA learning function using CompositionalNetworks.jl. If no error function is given when instantiating c, it will check the existence of a composition related to c and set the error to it.","category":"page"},{"location":"d_constraint/","page":"Constraints.jl","title":"Constraints.jl","text":"Follow the list of the constraints currently stored in usual_constraint. Note that if the constraint is named _my_constraint, it can be accessed as usual_constraint[:my_constraint].","category":"page"},{"location":"d_constraint/","page":"Constraints.jl","title":"Constraints.jl","text":"Constraints.all_different\nConstraints.all_equal\nConstraints.all_equal_param\nConstraints.dist_different\nConstraints.eq\nConstraints.ordered","category":"page"},{"location":"d_constraint/#Constraints.all_different","page":"Constraints.jl","title":"Constraints.all_different","text":"_all_different\n\nGlobal constraint ensuring that all the values of a given configuration are unique.\n\n\n\n\n\n","category":"constant"},{"location":"d_constraint/#Constraints.all_equal","page":"Constraints.jl","title":"Constraints.all_equal","text":"all_equal\n\nGlobal constraint ensuring that all the values of x are all equal.\n\n\n\n\n\n","category":"constant"},{"location":"d_constraint/#Constraints.all_equal_param","page":"Constraints.jl","title":"Constraints.all_equal_param","text":"all_equal_param\n\nGlobal constraint ensuring that all the values of x are all equal to a given parameter param.\n\n\n\n\n\n","category":"constant"},{"location":"d_constraint/#Constraints.dist_different","page":"Constraints.jl","title":"Constraints.dist_different","text":"dist_different\n\nLocal constraint ensuring that concept(dist_different, x) = |x[1] - x[2]| ≠ |x[3] - x[4]|).\n\n\n\n\n\n","category":"constant"},{"location":"d_constraint/#Constraints.eq","page":"Constraints.jl","title":"Constraints.eq","text":"eq\n\nEquality between two variables.\n\n\n\n\n\n","category":"constant"},{"location":"d_constraint/#Constraints.ordered","page":"Constraints.jl","title":"Constraints.ordered","text":"ordered(x)\n\nGlobal constraint ensuring that all the values of x are ordered.\n\n\n\n\n\n","category":"constant"},{"location":"d_constraint/","page":"Constraints.jl","title":"Constraints.jl","text":"Modules = [Constraints]\nPrivate = false","category":"page"},{"location":"d_constraint/#Constraints.usual_constraints","page":"Constraints.jl","title":"Constraints.usual_constraints","text":"usual_constraints::Dict\n\nDictionary that contains all the usual constraints defined in Constraint.jl.\n\n\n\n\n\n","category":"constant"},{"location":"d_constraint/#Constraints.usual_symmetries","page":"Constraints.jl","title":"Constraints.usual_symmetries","text":"symmetries\n\nA Dictionary that contains the function to apply for each symmetry to avoid searching a whole space.\n\n\n\n\n\n","category":"constant"},{"location":"d_constraint/#Constraints.Constraint","page":"Constraints.jl","title":"Constraints.Constraint","text":"Constraint\n\nParametric stucture with the following fields.\n\nconcept: a Boolean function that, given an assignment x, outputs true if x satisfies the constraint, and false otherwise.\nerror: a positive function that works as preferences over invalid assignements. Return 0.0 if the constraint is satisfied, and a strictly positive real otherwise.\n\n\n\n\n\n","category":"type"},{"location":"d_constraint/#Constraints.args_length-Tuple{Constraint}","page":"Constraints.jl","title":"Constraints.args_length","text":"args_length(c::Constraint)\n\nReturn the expected length restriction of the arguments in a constraint c. The value nothing indicates that any strictly positive number of value is accepted.\n\n\n\n\n\n","category":"method"},{"location":"d_constraint/#Constraints.concept-Tuple{Constraint}","page":"Constraints.jl","title":"Constraints.concept","text":"concept(c::Constraint)\n\nReturn the concept (function) of constraint c.     concept(c::Constraint, x...; param = nothing) Apply the concept of c to values x and optionally param.\n\n\n\n\n\n","category":"method"},{"location":"d_constraint/#Constraints.error_f-Tuple{Constraint}","page":"Constraints.jl","title":"Constraints.error_f","text":"error_f(c::Constraint)\n\nReturn the error function of constraint c.     error_f(c::Constraint, x; param = nothing) Apply the error function of c to values x and optionally param.\n\n\n\n\n\n","category":"method"},{"location":"d_constraint/#Constraints.params_length-Tuple{Constraint}","page":"Constraints.jl","title":"Constraints.params_length","text":"params_length(c::Constraint)\n\nReturn the expected length restriction of the arguments in a constraint c. The value nothing indicates that any strictly positive number of parameters is accepted.\n\n\n\n\n\n","category":"method"},{"location":"d_constraint/#Constraints.symmetries-Tuple{Constraint}","page":"Constraints.jl","title":"Constraints.symmetries","text":"symmetries(c::Constraint)\n\nReturn the list of symmetries of c.\n\n\n\n\n\n","category":"method"},{"location":"domain/#ConstraintDomains.jl","page":"ConstraintDomains.jl","title":"ConstraintDomains.jl","text":"","category":"section"},{"location":"domain/","page":"ConstraintDomains.jl","title":"ConstraintDomains.jl","text":"Currently discrete and continuous domains are supported using the following function.","category":"page"},{"location":"domain/","page":"ConstraintDomains.jl","title":"ConstraintDomains.jl","text":"ConstraintDomains.domain","category":"page"},{"location":"domain/#ConstraintDomains.domain","page":"ConstraintDomains.jl","title":"ConstraintDomains.domain","text":"domain()\n\nConstruct an EmptyDomain.\n\n\n\n\n\ndomain(a::Tuple{T, Bool}, b::Tuple{T, Bool}) where {T <: Real}\ndomain(intervals::Vector{Tuple{Tuple{T, Bool},Tuple{T, Bool}}}) where {T <: Real}\n\nConstruct a domain of continuous interval(s). ```julia d1 = domain((0., true), (1., false)) # d1 = [0, 1) d2 = domain([ # d2 = 0, 1) ∪ (3.5, 42, (1., false),     (3.5, false), (42., true), ])\n\n\n\n\n\ndomain(values)\ndomain(range::R) where {T <: Real, R <: AbstractRange{T}}\n\nConstruct either a SetDomain or a RangeDomain.\n\nd1 = domain(1:5)\nd2 = domain([53.69, 89.2, 0.12])\nd3 = domain([2//3, 89//123])\nd4 = domain(4.3)\n\n\n\n\n\n","category":"function"},{"location":"cbls/#CBLS.jl","page":"CBLS.jl","title":"CBLS.jl","text":"","category":"section"},{"location":"cbls/","page":"CBLS.jl","title":"CBLS.jl","text":"Modules = [CBLS]\nPrivate = false","category":"page"},{"location":"cbls/#CBLS.DiscreteSet","page":"CBLS.jl","title":"CBLS.DiscreteSet","text":"DiscreteSet(values)\n\n\n\n\n\n","category":"type"},{"location":"golomb/#Golomb-ruler","page":"Golomb ruler","title":"Golomb ruler","text":"","category":"section"},{"location":"golomb/","page":"Golomb ruler","title":"Golomb ruler","text":"Doc is still in construction. Please check golomb.jl in ConstraintModels.jl for details on the implementation. An extensive example is available as a quick-start guide to this package.","category":"page"},{"location":"golomb/#Constructing-a-Golomb-ruler-model","page":"Golomb ruler","title":"Constructing a Golomb ruler model","text":"","category":"section"},{"location":"golomb/","page":"Golomb ruler","title":"Golomb ruler","text":"ConstraintModels.golomb","category":"page"},{"location":"golomb/#ConstraintModels.golomb","page":"Golomb ruler","title":"ConstraintModels.golomb","text":"golomb(n, L=n²)\n\nModel the Golomb problem of n marks on the ruler 0:L. The modeler argument accepts :raw, and :JuMP (default), which refer respectively to the solver internal model, the MathOptInterface model, and the JuMP model.\n\n\n\n\n\n","category":"function"},{"location":"icn/#CompositionalNetworks.jl","page":"CompositionalNetworks.jl","title":"CompositionalNetworks.jl","text":"","category":"section"},{"location":"icn/","page":"CompositionalNetworks.jl","title":"CompositionalNetworks.jl","text":"Pages = [\"public.md\"]\nDepth = 5","category":"page"},{"location":"icn/","page":"CompositionalNetworks.jl","title":"CompositionalNetworks.jl","text":"CompositionalNetworks.jl, a Julia package for Interpretable Compositional Networks (ICN), a variant of neural networks, allowing the user to get interpretable results, unlike regular artificial neural networks.","category":"page"},{"location":"icn/","page":"CompositionalNetworks.jl","title":"CompositionalNetworks.jl","text":"The current state of our ICN focuses on the composition of error functions for LocalSearchSolvers.jl, but produces results independently of it and export it to either/both Julia functions or/and human readable output.","category":"page"},{"location":"icn/#How-does-it-work?","page":"CompositionalNetworks.jl","title":"How does it work?","text":"","category":"section"},{"location":"icn/","page":"CompositionalNetworks.jl","title":"CompositionalNetworks.jl","text":"The package comes with a basic ICN for learning global constraints. The ICN is composed of 4 layers: transformation, arithmetic, aggregation, and comparison. Each contains several operations that can be composed in various ways. Given a concept (a predicate over the variables' domains), a metric (hamming by default), and the variables' domains, we learn the binary weights of the ICN.","category":"page"},{"location":"icn/#Installation","page":"CompositionalNetworks.jl","title":"Installation","text":"","category":"section"},{"location":"icn/","page":"CompositionalNetworks.jl","title":"CompositionalNetworks.jl","text":"] add CompositionalNetworks","category":"page"},{"location":"icn/","page":"CompositionalNetworks.jl","title":"CompositionalNetworks.jl","text":"As the package is in a beta version, some changes in the syntax and features are likely to occur. However, those changes should be minimal between minor versions. Please update with caution.","category":"page"},{"location":"icn/#Quickstart","page":"CompositionalNetworks.jl","title":"Quickstart","text":"","category":"section"},{"location":"icn/","page":"CompositionalNetworks.jl","title":"CompositionalNetworks.jl","text":"# 4 variables in 1:4\ndoms = [domain([1,2,3,4]) for i in 1:4]\n\n# allunique concept (that is used to define the :all_different constraint)\nerr = explore_learn_compose(allunique, domains=doms)\n# > interpretation: identity ∘ count_positive ∘ sum ∘ count_eq_left\n\n# test our new error function\n@assert err([1,2,3,3], dom_size = 4) > 0.0\n\n# export an all_different function to file \"current/path/test_dummy.jl\"\ncompose_to_file!(icn, \"all_different\", \"test_dummy.jl\")","category":"page"},{"location":"icn/","page":"CompositionalNetworks.jl","title":"CompositionalNetworks.jl","text":"The output file should produces a function that can be used as follows (assuming the maximum domain size is 7)","category":"page"},{"location":"icn/","page":"CompositionalNetworks.jl","title":"CompositionalNetworks.jl","text":"import CompositionalNetworks\n\nall_different([1,2,3,4,5,6,7]; dom_size = 7)\n# > 0.0 (which means true, no errors)","category":"page"},{"location":"icn/","page":"CompositionalNetworks.jl","title":"CompositionalNetworks.jl","text":"Please see JuliaConstraints/Constraints.jl/learn.jl for an extensive example of ICN learning and compositions.","category":"page"},{"location":"icn/#Public-interface","page":"CompositionalNetworks.jl","title":"Public interface","text":"","category":"section"},{"location":"icn/","page":"CompositionalNetworks.jl","title":"CompositionalNetworks.jl","text":"Modules = [CompositionalNetworks]\nPrivate = false","category":"page"},{"location":"icn/#CompositionalNetworks.ICN","page":"CompositionalNetworks.jl","title":"CompositionalNetworks.ICN","text":"ICN(; nvars, dom_size, param, transformation, arithmetic, aggregation, comparison)\n\nConstruct an Interpretable Compositional Network, with the following arguments:\n\nnvars: number of variable in the constraint\ndom_size: maximum domain size of any variable in the constraint\nparam: optional parameter (default to nothing)\ntransformation: a transformation layer (optional)\narithmetic: a arithmetic layer (optional)\naggregation: a aggregation layer (optional)\ncomparison: a comparison layer (optional)\n\n\n\n\n\n","category":"type"},{"location":"icn/#CompositionalNetworks.aggregation_layer-Tuple{}","page":"CompositionalNetworks.jl","title":"CompositionalNetworks.aggregation_layer","text":"aggregation_layer()\n\nGenerate the layer of aggregations of the ICN. The operations are mutually exclusive, that is only one will be selected.\n\n\n\n\n\n","category":"method"},{"location":"icn/#CompositionalNetworks.arithmetic_layer-Tuple{}","page":"CompositionalNetworks.jl","title":"CompositionalNetworks.arithmetic_layer","text":"arithmetic_layer()\n\nGenerate the layer of arithmetic operations of the ICN. The operations are mutually exclusive, that is only one will be selected.\n\n\n\n\n\n","category":"method"},{"location":"icn/#CompositionalNetworks.comparison_layer","page":"CompositionalNetworks.jl","title":"CompositionalNetworks.comparison_layer","text":"comparison_layer(param = false)\n\nGenerate the layer of transformations functions of the ICN. Iff param value is set, also includes all the parametric comparison with that value. The operations are mutually exclusive, that is only one will be selected.\n\n\n\n\n\n","category":"function"},{"location":"icn/#CompositionalNetworks.compose-Tuple{ICN}","page":"CompositionalNetworks.jl","title":"CompositionalNetworks.compose","text":"compose(icn)\ncompose(icn, weights)\n\nReturn a function composed by some of the operations of a given ICN. Can be applied to any vector of variables. If weights are given, will assign to icn.\n\n\n\n\n\n","category":"method"},{"location":"icn/#CompositionalNetworks.compose_to_file!","page":"CompositionalNetworks.jl","title":"CompositionalNetworks.compose_to_file!","text":"compose_to_file!(icn::ICN, name, path, language = :Julia)\n\nCompose a string that describes mathematically the composition of an ICN and write it to a file.\n\nArguments:\n\nicn: a given compositional network with a learned composition\nname: name of the composition\npath: path of the output file\nlanguage: targeted programming language\n\n\n\n\n\n","category":"function"},{"location":"icn/#CompositionalNetworks.compose_to_file!-Tuple{Any, Any, Any}","page":"CompositionalNetworks.jl","title":"CompositionalNetworks.compose_to_file!","text":"compose_to_file!(concept, name, path; domains, param = nothing, language = :Julia, search = :complete, global_iter = 10, local_iter = 100, metric = hamming, popSize = 200)\n\nExplore, learn and compose a function and write it to a file.\n\nArguments:\n\nconcept: the concept to learn\nname: the name to give to the constraint\npath: path of the output file\n\nKeywords arguments:\n\ndomains: domains that defines the search space\nparam: an optional paramater of the constraint\nlanguage: the language to export to, default to :julia\nsearch: either :partial or :complete search\nglobal_iter: number of learning iteration\nlocal_iter: number of generation in the genetic algorithm\nmetric: the metric to measure the distance between a configuration and known solutions\npopSize: size of the population in the genetic algorithm\n\n\n\n\n\n","category":"method"},{"location":"icn/#CompositionalNetworks.explore_learn_compose-Tuple{Any}","page":"CompositionalNetworks.jl","title":"CompositionalNetworks.explore_learn_compose","text":"explore_learn_compose(concept; domains, param = nothing, search = :complete, global_iter = 10, local_iter = 100, metric = hamming, popSize = 200, action = :composition)\n\nExplore a search space, learn a composition from an ICN, and compose an error function.\n\nArguments:\n\nconcept: the concept of the targeted constraint\ndomains: domains of the variables that define the training space\nparam: an optional parameter of the constraint\nsearch: either :partial or :complete search\nglobal_iter: number of learning iteration\nlocal_iter: number of generation in the genetic algorithm\nmetric: the metric to measure the distance between a configuration and known solutions\npopSize: size of the population in the genetic algorithm\naction: either :symbols to have a description of the composition or :composition to have the composed function itself\n\n\n\n\n\n","category":"method"},{"location":"icn/#CompositionalNetworks.hamming-Tuple{Any, Any}","page":"CompositionalNetworks.jl","title":"CompositionalNetworks.hamming","text":"hamming(x, X)\n\nCompute the hamming distance of x over a collection of solutions X, i.e. the minimal number of variables to switch in xto reach a solution.\n\n\n\n\n\n","category":"method"},{"location":"icn/#CompositionalNetworks.lazy-Tuple{Vararg{Function, N} where N}","page":"CompositionalNetworks.jl","title":"CompositionalNetworks.lazy","text":"lazy(funcs::Function...)\n\nGenerate methods extended to a vector instead of one of its components. A function f should have the following signature: f(i::Int, x::V; param = nothing).\n\n\n\n\n\n","category":"method"},{"location":"icn/#CompositionalNetworks.lazy_param-Tuple{Vararg{Function, N} where N}","page":"CompositionalNetworks.jl","title":"CompositionalNetworks.lazy_param","text":"lazy_param(funcs::Function...)\n\nGenerate methods extended to a vector instead of one of its components. A function f should have the following signature: f(i::Int, x::V; param).\n\n\n\n\n\n","category":"method"},{"location":"icn/#CompositionalNetworks.learn_compose","page":"CompositionalNetworks.jl","title":"CompositionalNetworks.learn_compose","text":"learn_compose(;\n    nvars, dom_size, param=nothing, icn=ICN(nvars, dom_size, param),\n    X, X_sols, global_iter=100, local_iter=100, metric=hamming, popSize=200\n)\n\nCreate an ICN, optimize it, and return its composition.\n\n\n\n\n\n","category":"function"},{"location":"icn/#CompositionalNetworks.optimize!","page":"CompositionalNetworks.jl","title":"CompositionalNetworks.optimize!","text":"optimize!(icn, X, X_sols, global_iter, local_iter; metric=hamming, popSize=100)\n\nOptimize and set the weigths of an ICN with a given set of configuration X and solutions X_sols. The best weigths among global_iter will be set.\n\n\n\n\n\n","category":"function"},{"location":"icn/#CompositionalNetworks.regularization-Tuple{Any}","page":"CompositionalNetworks.jl","title":"CompositionalNetworks.regularization","text":"regularization(icn)\n\nReturn the regularization value of an ICN weights, which is proportional to the normalized number of operations selected in the icn layers.\n\n\n\n\n\n","category":"method"},{"location":"icn/#CompositionalNetworks.show_composition-Tuple{Any}","page":"CompositionalNetworks.jl","title":"CompositionalNetworks.show_composition","text":"show_composition(icn)\n\nReturn the composition (weights) of an ICN.\n\n\n\n\n\n","category":"method"},{"location":"icn/#CompositionalNetworks.show_layers-Tuple{Any}","page":"CompositionalNetworks.jl","title":"CompositionalNetworks.show_layers","text":"show_layers(icn)\n\nReturn a formated string with each layers in the icn.\n\n\n\n\n\n","category":"method"},{"location":"icn/#CompositionalNetworks.transformation_layer","page":"CompositionalNetworks.jl","title":"CompositionalNetworks.transformation_layer","text":"transformation_layer(param = false)\n\nGenerate the layer of transformations functions of the ICN. Iff param value is true, also includes all the parametric transformations.\n\n\n\n\n\n","category":"function"},{"location":"models/#ConstraintModels.jl","page":"ConstraintModels.jl","title":"ConstraintModels.jl","text":"","category":"section"},{"location":"models/","page":"ConstraintModels.jl","title":"ConstraintModels.jl","text":"Modules = [ConstraintModels]\nPrivate = false","category":"page"},{"location":"models/#ConstraintModels.golomb","page":"ConstraintModels.jl","title":"ConstraintModels.golomb","text":"golomb(n, L=n²)\n\nModel the Golomb problem of n marks on the ruler 0:L. The modeler argument accepts :raw, and :JuMP (default), which refer respectively to the solver internal model, the MathOptInterface model, and the JuMP model.\n\n\n\n\n\n","category":"function"},{"location":"models/#ConstraintModels.magic_square-Tuple{Any}","page":"ConstraintModels.jl","title":"ConstraintModels.magic_square","text":"magic_square(n; modeler = :JuMP)\n\nCreate a model for the magic square problem of order n. The modeler argument accepts :JuMP (default), which refer to the solver the JuMP model.\n\n\n\n\n\n","category":"method"},{"location":"models/#ConstraintModels.mincut-Tuple{Any}","page":"ConstraintModels.jl","title":"ConstraintModels.mincut","text":"mincut(graph::AbstractMatrix{T}; source::Int, sink::Int, interdiction::Int = 0) where T <: Number\n\nCompute the minimum cut of a graph.\n\nArguments:\n\ngraph: Any matrix <: AbstractMatrix that describes the capacities of the graph\nsource: Id of the source node; must be set\nsink: Id of the sink node; must be set\ninterdiction: indicates the number of forbidden links\n\n\n\n\n\n","category":"method"},{"location":"models/#ConstraintModels.n_queens-Tuple{Any}","page":"ConstraintModels.jl","title":"ConstraintModels.n_queens","text":"n_queens(n; modeler = :JuMP)\n\nCreate a model for the n-queens problem with n queens. The modeler argument accepts :JuMP (default), which refer to the JuMP model.\n\n\n\n\n\n","category":"method"},{"location":"models/#ConstraintModels.sudoku-Tuple{Any}","page":"ConstraintModels.jl","title":"ConstraintModels.sudoku","text":"sudoku(n; start= Dictionary{Int, Int}(), modeler = :JuMP)\n\nCreate a model for the sudoku problem of domain 1:n² with optional starting values. The modeler argument accepts :raw, :MOI, and :JuMP (default), which refer respectively to the solver internal model, the MathOptInterface model, and the JuMP model.\n\n# Construct a JuMP model `m` and its associated matrix `grid` for sudoku 9×9\nm, grid = sudoku(3)\n\n# Same with a starting instance\ninstance = [\n    9  3  0  0  0  0  0  4  0\n    0  0  0  0  4  2  0  9  0\n    8  0  0  1  9  6  7  0  0\n    0  0  0  4  7  0  0  0  0\n    0  2  0  0  0  0  0  6  0\n    0  0  0  0  2  3  0  0  0\n    0  0  8  5  3  1  0  0  2\n    0  9  0  2  8  0  0  0  0\n    0  7  0  0  0  0  0  5  3\n]\nm, grid = sudoku(3, start = instance)\n\n# Run the solver\noptimize!(m)\n\n# Retrieve and display the values\nsolution = value.(grid)\ndisplay(solution, Val(:sudoku))\n\n\n\n\n\n","category":"method"},{"location":"internals/#Internal","page":"Internals","title":"Internal","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"Pages = [\"internal.md\"]\nDepth = 5","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Modules = [LocalSearchSolvers]\nPublic = false","category":"page"},{"location":"internals/#LocalSearchSolvers.AbstractSolver","page":"Internals","title":"LocalSearchSolvers.AbstractSolver","text":"AbstractSolver\n\nAbstract type to encapsulate the different solver types such as Solver or _SubSolver.\n\n\n\n\n\n","category":"type"},{"location":"internals/#LocalSearchSolvers.Constraint","page":"Internals","title":"LocalSearchSolvers.Constraint","text":"Constraint{F <: Function}\n\nStructure to store an error function and the variables it constrains.\n\n\n\n\n\n","category":"type"},{"location":"internals/#LocalSearchSolvers.LeadSolver","page":"Internals","title":"LocalSearchSolvers.LeadSolver","text":"LeadSolver <: MetaSolver\n\nSolver managed remotely by a MainSolver. Can manage its own set of local sub solvers.\n\n\n\n\n\n","category":"type"},{"location":"internals/#LocalSearchSolvers.MainSolver","page":"Internals","title":"LocalSearchSolvers.MainSolver","text":"MainSolver <: AbstractSolver\n\nMain solver. Handle the solving of a model, and optional multithreaded and/or distributed subsolvers.\n\nArguments:\n\nmodel::Model: A formal description of the targeted problem\nstate::_State: An internal state to store the info necessary to a solving run\noptions::Options: User options for this solver\nsubs::Vector{_SubSolver}: Optional subsolvers\n\n\n\n\n\n","category":"type"},{"location":"internals/#LocalSearchSolvers.MetaSolver","page":"Internals","title":"LocalSearchSolvers.MetaSolver","text":"Abstract type to encapsulate all solver types that manages other solvers.\n\n\n\n\n\n","category":"type"},{"location":"internals/#LocalSearchSolvers.Objective","page":"Internals","title":"LocalSearchSolvers.Objective","text":"Objective{F <: Function}\n\nA structure to handle objectives in a solver. struct Objective{F <: Function}     name::String     f::F end`\n\n\n\n\n\n","category":"type"},{"location":"internals/#LocalSearchSolvers.Objective-Union{Tuple{F2}, Tuple{Any, LocalSearchSolvers.Objective{F2}}} where F2<:Function","page":"Internals","title":"LocalSearchSolvers.Objective","text":"Objective(F, o::Objective{F2}) where {F2 <: Function}\n\nConstructor used in specializing a solver. Should never be called externally.\n\n\n\n\n\n","category":"method"},{"location":"internals/#LocalSearchSolvers.Variable","page":"Internals","title":"LocalSearchSolvers.Variable","text":"Variable{D <: AbstractDomain}\n\nA structure containing the necessary information for a solver's variables: name, domain, and constraints it belongs.\n\nstruct Variable{D <: AbstractDomain}\n    domain::D\n    constraints::Indices{Int}\nend\n\n\n\n\n\n","category":"type"},{"location":"internals/#LocalSearchSolvers._Model","page":"Internals","title":"LocalSearchSolvers._Model","text":"_Model{V <: Variable{<:AbstractDomain},C <: Constraint{<:Function},O <: Objective{<:Function}}\n\nA struct to model a problem as a set of variables, domains, constraints, and objectives.\n\nstruct _Model{V <: Variable{<:AbstractDomain},C <: Constraint{<:Function},O <: Objective{<:Function}}\n    variables::Dictionary{Int,V}\n    constraints::Dictionary{Int,C}\n    objectives::Dictionary{Int,O}\n\n    # counter to add new variables: vars, cons, objs\n    max_vars::Ref{Int}\n    max_cons::Ref{Int}\n    max_objs::Ref{Int}\n\n    # Bool to indicate if the _Model instance has been specialized (relatively to types)\n    specialized::Ref{Bool}\n\n    # Symbol to indicate the kind of model for specialized methods such as pretty printing\n    kind::Symbol\nend\n\n\n\n\n\n","category":"type"},{"location":"internals/#LocalSearchSolvers._State","page":"Internals","title":"LocalSearchSolvers._State","text":"GeneralState{T <: Number}\n\nA mutable structure to store the general state of a solver. All methods applied to GeneralState are forwarded to S <: AbstractSolver.\n\nmutable struct GeneralState{T <: Number} <: AbstractState\n    configuration::Configuration{T}\n    cons_costs::Dictionary{Int, Float64}\n    last_improvement::Int\n    tabu::Dictionary{Int, Int}\n    vars_costs::Dictionary{Int, Float64}\nend\n\n\n\n\n\n","category":"type"},{"location":"internals/#LocalSearchSolvers._SubSolver","page":"Internals","title":"LocalSearchSolvers._SubSolver","text":"_SubSolver <: AbstractSolver\n\nAn internal solver type called by MetaSolver when multithreading is enabled.\n\nArguments:\n\nid::Int: subsolver id for debugging\nmodel::Model: a ref to the model of the main solver\nstate::_State: a deepcopy of the main solver that evolves independently\noptions::Options: a ref to the options of the main solver\n\n\n\n\n\n","category":"type"},{"location":"internals/#Base.empty!-Tuple{LocalSearchSolvers.MainSolver}","page":"Internals","title":"Base.empty!","text":"empty!(s::Solver)\n\nDOCSTRING\n\n\n\n\n\n","category":"method"},{"location":"internals/#Base.empty!-Tuple{LocalSearchSolvers._Model}","page":"Internals","title":"Base.empty!","text":"empty!(m::Model)\n\nDOCSTRING\n\n\n\n\n\n","category":"method"},{"location":"internals/#Base.in-Tuple{Int64, LocalSearchSolvers.Constraint}","page":"Internals","title":"Base.in","text":"var::Int ∈ c::Constraint\n\n\n\n\n\n","category":"method"},{"location":"internals/#Base.in-Tuple{LocalSearchSolvers.Variable, Any}","page":"Internals","title":"Base.in","text":"x::Variable ∈ constraint\nvalue ∈ x::Variable\n\nCheck if a variable x is restricted by a constraint::Int, or if a value belongs to the domain of x.\n\n\n\n\n\n","category":"method"},{"location":"internals/#LocalSearchSolvers._add!-Tuple{LocalSearchSolvers.Constraint, Any}","page":"Internals","title":"LocalSearchSolvers._add!","text":"_add!(c::Constraint, x)\n\nAdd the variable of indice x to c.\n\n\n\n\n\n","category":"method"},{"location":"internals/#LocalSearchSolvers._add_to_constraint!-Tuple{LocalSearchSolvers.Variable, Any}","page":"Internals","title":"LocalSearchSolvers._add_to_constraint!","text":"_add_to_constraint!(x::Variable, id)\n\nAdd a constraint id to the list of contraints of x.\n\n\n\n\n\n","category":"method"},{"location":"internals/#LocalSearchSolvers._check_restart-Tuple{Any}","page":"Internals","title":"LocalSearchSolvers._check_restart","text":"_check_restart(s)\n\nCheck if a restart of s is necessary. If s has subsolvers, this check is independent for all of them.\n\n\n\n\n\n","category":"method"},{"location":"internals/#LocalSearchSolvers._check_subs-Tuple{Any}","page":"Internals","title":"LocalSearchSolvers._check_subs","text":"_check_subs(s)\n\nCheck if any subsolver of a main solver s, for\n\nSatisfaction, has a solution, then return it, resume the run otherwise\nOptimization, has a better solution, then assign it to its internal state\n\n\n\n\n\n","category":"method"},{"location":"internals/#LocalSearchSolvers._compute!-Tuple{Any}","page":"Internals","title":"LocalSearchSolvers._compute!","text":"_compute!(s; o::Int = 1, cons_lst = Indices{Int}())\n\nCompute the objective o's value if s is satisfied and return the current error.\n\nArguments:\n\ns: a solver\no: targeted objective\ncons_lst: list of targeted constraints, if empty compute for the whole set\n\n\n\n\n\n","category":"method"},{"location":"internals/#LocalSearchSolvers._compute_cost!-Tuple{Any, Any, Any}","page":"Internals","title":"LocalSearchSolvers._compute_cost!","text":"_compute_cost!(s, ind, c)\n\nCompute the cost of constraint c with index ind.\n\n\n\n\n\n","category":"method"},{"location":"internals/#LocalSearchSolvers._compute_costs!-Tuple{Any}","page":"Internals","title":"LocalSearchSolvers._compute_costs!","text":"_compute_costs!(s; cons_lst::Indices{Int} = Indices{Int}())\n\nCompute the cost of constraints c in cons_lst. If cons_lst is empty, compute the cost for all the constraints in s.\n\n\n\n\n\n","category":"method"},{"location":"internals/#LocalSearchSolvers._compute_objective!-Tuple{Any, LocalSearchSolvers.Objective}","page":"Internals","title":"LocalSearchSolvers._compute_objective!","text":"_compute_objective!(s, o::Objective)\n_compute_objective!(s, o = 1)\n\nCompute the objective o's value.\n\n\n\n\n\n","category":"method"},{"location":"internals/#LocalSearchSolvers._cons_cost!-Tuple{LocalSearchSolvers._State, Any, Any}","page":"Internals","title":"LocalSearchSolvers._cons_cost!","text":"_cons_cost!(s::S, c, cost) where S <: Union{_State, AbstractSolver}\n\nSet the cost of constraint c.\n\n\n\n\n\n","category":"method"},{"location":"internals/#LocalSearchSolvers._cons_cost-Tuple{LocalSearchSolvers._State, Any}","page":"Internals","title":"LocalSearchSolvers._cons_cost","text":"_cons_cost(s::S, c) where S <: Union{_State, AbstractSolver}\n\nReturn the cost of constraint c.\n\n\n\n\n\n","category":"method"},{"location":"internals/#LocalSearchSolvers._cons_costs!-Tuple{LocalSearchSolvers._State, Any}","page":"Internals","title":"LocalSearchSolvers._cons_costs!","text":"_cons_costs!(s::S, costs) where S <: Union{_State, AbstractSolver}\n\nSet the constraints costs.\n\n\n\n\n\n","category":"method"},{"location":"internals/#LocalSearchSolvers._cons_costs-Tuple{LocalSearchSolvers._State}","page":"Internals","title":"LocalSearchSolvers._cons_costs","text":"_cons_costs(s::S) where S <: Union{_State, AbstractSolver}\n\nAccess the constraints costs.\n\n\n\n\n\n","category":"method"},{"location":"internals/#LocalSearchSolvers._constriction-Tuple{LocalSearchSolvers.Variable}","page":"Internals","title":"LocalSearchSolvers._constriction","text":"_constriction(x::Variable)\n\nReturn the cosntriction of x, i.e. the number of constraints restricting x.\n\n\n\n\n\n","category":"method"},{"location":"internals/#LocalSearchSolvers._delete!-Tuple{LocalSearchSolvers.Constraint, Any}","page":"Internals","title":"LocalSearchSolvers._delete!","text":"_delete!(c::Constraint, x::Int)\n\nDelete x from c.\n\n\n\n\n\n","category":"method"},{"location":"internals/#LocalSearchSolvers._delete_from_constraint!-Tuple{LocalSearchSolvers.Variable, Any}","page":"Internals","title":"LocalSearchSolvers._delete_from_constraint!","text":"_delete_from_constraint!(x::Variable, id)\n\nDelete a constraint id from the list of contraints of x.\n\n\n\n\n\n","category":"method"},{"location":"internals/#LocalSearchSolvers._draw!-Tuple{Any}","page":"Internals","title":"LocalSearchSolvers._draw!","text":"_draw!(s)\n\nDraw a random (re-)starting configuration.\n\n\n\n\n\n","category":"method"},{"location":"internals/#LocalSearchSolvers._find_rand_argmax-Tuple{Dictionaries.DictionaryView}","page":"Internals","title":"LocalSearchSolvers._find_rand_argmax","text":"_find_rand_argmax(d::DictionaryView)\n\nCompute argmax of d and select one element randomly.\n\n\n\n\n\n","category":"method"},{"location":"internals/#LocalSearchSolvers._get_constraints-Tuple{LocalSearchSolvers.Variable}","page":"Internals","title":"LocalSearchSolvers._get_constraints","text":"_get_constraints(x::Variable)\n\nAccess the list of constraints of x.\n\n\n\n\n\n","category":"method"},{"location":"internals/#LocalSearchSolvers._get_vars-Tuple{LocalSearchSolvers.Constraint}","page":"Internals","title":"LocalSearchSolvers._get_vars","text":"_get_vars(c::Constraint)\n\nReturns the variables constrained by c.\n\n\n\n\n\n","category":"method"},{"location":"internals/#LocalSearchSolvers._inc_cons!-Tuple{LocalSearchSolvers._Model}","page":"Internals","title":"LocalSearchSolvers._inc_cons!","text":"_inc_vars!(m::M) where M <: Union{Model, AbstractSolver}\n\nIncrement the maximum constraint id that has been attributed to m.\n\n\n\n\n\n","category":"method"},{"location":"internals/#LocalSearchSolvers._inc_objs!-Tuple{LocalSearchSolvers._Model}","page":"Internals","title":"LocalSearchSolvers._inc_objs!","text":"_inc_vars!(m::M) where M <: Union{Model, AbstractSolver}\n\nIncrement the maximum objective id that has been attributed to m.\n\n\n\n\n\n","category":"method"},{"location":"internals/#LocalSearchSolvers._inc_vars!-Tuple{LocalSearchSolvers._Model}","page":"Internals","title":"LocalSearchSolvers._inc_vars!","text":"_inc_vars!(m::M) where M <: Union{Model, AbstractSolver}\n\nIncrement the maximum variable id that has been attributed to m.\n\n\n\n\n\n","category":"method"},{"location":"internals/#LocalSearchSolvers._is_empty-Tuple{LocalSearchSolvers._Model}","page":"Internals","title":"LocalSearchSolvers._is_empty","text":"_is_empty(m::Model)\n\nDOCSTRING\n\n\n\n\n\n","category":"method"},{"location":"internals/#LocalSearchSolvers._length-Tuple{LocalSearchSolvers.Constraint}","page":"Internals","title":"LocalSearchSolvers._length","text":"_length(c::Constraint)\n\nReturn the number of constrained variables by c.\n\n\n\n\n\n","category":"method"},{"location":"internals/#LocalSearchSolvers._max_cons-Tuple{LocalSearchSolvers._Model}","page":"Internals","title":"LocalSearchSolvers._max_cons","text":"_max_cons(m::M) where M <: Union{Model, AbstractSolver}\n\nAccess the maximum constraint id that has been attributed to m.\n\n\n\n\n\n","category":"method"},{"location":"internals/#LocalSearchSolvers._max_objs-Tuple{LocalSearchSolvers._Model}","page":"Internals","title":"LocalSearchSolvers._max_objs","text":"_max_objs(m::M) where M <: Union{Model, AbstractSolver}\n\nAccess the maximum objective id that has been attributed to m.\n\n\n\n\n\n","category":"method"},{"location":"internals/#LocalSearchSolvers._max_vars-Tuple{LocalSearchSolvers._Model}","page":"Internals","title":"LocalSearchSolvers._max_vars","text":"_max_vars(m::M) where M <: Union{Model, AbstractSolver}\n\nAccess the maximum variable id that has been attributed to m.\n\n\n\n\n\n","category":"method"},{"location":"internals/#LocalSearchSolvers._move!","page":"Internals","title":"LocalSearchSolvers._move!","text":"_move!(s, x::Int, dim::Int = 0)\n\nPerform an improving move in x neighbourhood if possible.\n\nArguments:\n\ns: a solver of type S <: AbstractSolver\nx: selected variable id\ndim: describe the dimension of the considered neighbourhood\n\n\n\n\n\n","category":"function"},{"location":"internals/#LocalSearchSolvers._neighbours","page":"Internals","title":"LocalSearchSolvers._neighbours","text":"_neighbours(s, x, dim = 0)\n\nDOCSTRING\n\nArguments:\n\ns: DESCRIPTION\nx: DESCRIPTION\ndim: DESCRIPTION\n\n\n\n\n\n","category":"function"},{"location":"internals/#LocalSearchSolvers._optimizing!-Tuple{LocalSearchSolvers._State}","page":"Internals","title":"LocalSearchSolvers._optimizing!","text":"_optimizing!(s::S) where S <: Union{_State, AbstractSolver}\n\nSet the solver optimizing status to true.\n\n\n\n\n\n","category":"method"},{"location":"internals/#LocalSearchSolvers._optimizing-Tuple{LocalSearchSolvers._State}","page":"Internals","title":"LocalSearchSolvers._optimizing","text":"_optimizing(s::S) where S <: Union{_State, AbstractSolver}\n\nCheck if s is in an optimizing state.\n\n\n\n\n\n","category":"method"},{"location":"internals/#LocalSearchSolvers._print_level!-Tuple{Any, Any}","page":"Internals","title":"LocalSearchSolvers._print_level!","text":"_print_level!(options, level) = begin\n\nDOCSTRING\n\n\n\n\n\n","category":"method"},{"location":"internals/#LocalSearchSolvers._restart!","page":"Internals","title":"LocalSearchSolvers._restart!","text":"_restart!(s, k = 10)\n\nRestart a solver.\n\n\n\n\n\n","category":"function"},{"location":"internals/#LocalSearchSolvers._satisfying!-Tuple{LocalSearchSolvers._State}","page":"Internals","title":"LocalSearchSolvers._satisfying!","text":"_satisfying!(s::S) where S <: Union{_State, AbstractSolver}\n\nSet the solver optimizing status to false.\n\n\n\n\n\n","category":"method"},{"location":"internals/#LocalSearchSolvers._select_worse-Tuple{Any}","page":"Internals","title":"LocalSearchSolvers._select_worse","text":"_select_worse(s::S) where S <: Union{_State, AbstractSolver}\n\nWithin the non-tabu variables, select the one with the worse error .\n\n\n\n\n\n","category":"method"},{"location":"internals/#LocalSearchSolvers._set!-Tuple{LocalSearchSolvers._State, Any, Any}","page":"Internals","title":"LocalSearchSolvers._set!","text":"_set!(s::S, x, val) where S <: Union{_State, AbstractSolver}\n\nSet the value of variable x to val.\n\n\n\n\n\n","category":"method"},{"location":"internals/#LocalSearchSolvers._solve!-Tuple{Any, Any}","page":"Internals","title":"LocalSearchSolvers._solve!","text":"_solve!(s, stop)\n\nStart a solving run of a subsolver with a shared Atomic boolean stop.\n\n\n\n\n\n","category":"method"},{"location":"internals/#LocalSearchSolvers._specialize-Tuple{Any}","page":"Internals","title":"LocalSearchSolvers._specialize","text":"_specialize(options) = begin\n\nDOCSTRING\n\n\n\n\n\n","category":"method"},{"location":"internals/#LocalSearchSolvers._step!-Tuple{Any}","page":"Internals","title":"LocalSearchSolvers._step!","text":"_step!(s)\n\nIterate a step of the solver run.\n\n\n\n\n\n","category":"method"},{"location":"internals/#LocalSearchSolvers._swap_value!-Tuple{LocalSearchSolvers._State, Any, Any}","page":"Internals","title":"LocalSearchSolvers._swap_value!","text":"_set!(s::S, x, y) where S <: Union{_State, AbstractSolver}\n\nSwap the values of variables x and y.\n\n\n\n\n\n","category":"method"},{"location":"internals/#LocalSearchSolvers._tabu_delta!-Tuple{Any, Any}","page":"Internals","title":"LocalSearchSolvers._tabu_delta!","text":"_tabu_delta!(options, time) = begin\n\nDOCSTRING\n\n\n\n\n\n","category":"method"},{"location":"internals/#LocalSearchSolvers._tabu_delta-Tuple{Any}","page":"Internals","title":"LocalSearchSolvers._tabu_delta","text":"_tabu_delta(options) = begin\n\nDOCSTRING\n\n\n\n\n\n","category":"method"},{"location":"internals/#LocalSearchSolvers._tabu_local!-Tuple{Any, Any}","page":"Internals","title":"LocalSearchSolvers._tabu_local!","text":"_tabu_local!(options, time) = begin\n\nDOCSTRING\n\n\n\n\n\n","category":"method"},{"location":"internals/#LocalSearchSolvers._tabu_local-Tuple{Any}","page":"Internals","title":"LocalSearchSolvers._tabu_local","text":"_tabu_local(options) = begin\n\nDOCSTRING\n\n\n\n\n\n","category":"method"},{"location":"internals/#LocalSearchSolvers._tabu_time!-Tuple{Any, Any}","page":"Internals","title":"LocalSearchSolvers._tabu_time!","text":"_tabu_time!(options, time) = begin\n\nDOCSTRING\n\n\n\n\n\n","category":"method"},{"location":"internals/#LocalSearchSolvers._tabu_time-Tuple{Any}","page":"Internals","title":"LocalSearchSolvers._tabu_time","text":"_tabu_time(options) = begin\n\nDOCSTRING\n\n\n\n\n\n","category":"method"},{"location":"internals/#LocalSearchSolvers._threads-Tuple{Any}","page":"Internals","title":"LocalSearchSolvers._threads","text":"_threads(options) = begin\n\nDOCSTRING\n\n\n\n\n\n","category":"method"},{"location":"internals/#LocalSearchSolvers._to_union-Tuple{Any}","page":"Internals","title":"LocalSearchSolvers._to_union","text":"_to_union(datatype)\n\nMake a minimal Union type from a collection of data types.\n\n\n\n\n\n","category":"method"},{"location":"internals/#LocalSearchSolvers._value!-Tuple{LocalSearchSolvers._State, Any, Any}","page":"Internals","title":"LocalSearchSolvers._value!","text":"_value!(s::S, x, val) where S <: Union{_State, AbstractSolver}\n\nSet the value of variable x to val.\n\n\n\n\n\n","category":"method"},{"location":"internals/#LocalSearchSolvers._value-Tuple{LocalSearchSolvers._State, Any}","page":"Internals","title":"LocalSearchSolvers._value","text":"_value(s::S, x) where S <: Union{_State, AbstractSolver}\n\nReturn the value of variable x.\n\n\n\n\n\n","category":"method"},{"location":"internals/#LocalSearchSolvers._values!-Union{Tuple{T}, Tuple{LocalSearchSolvers._State{T}, Any}} where T<:Number","page":"Internals","title":"LocalSearchSolvers._values!","text":"_values!(s::S, values) where S <: Union{_State, AbstractSolver}\n\nSet the variables values.\n\n\n\n\n\n","category":"method"},{"location":"internals/#LocalSearchSolvers._values-Tuple{LocalSearchSolvers._State}","page":"Internals","title":"LocalSearchSolvers._values","text":"_vars_costs(s::S) where S <: Union{_State, AbstractSolver}\n\nAccess the variables costs.\n\n\n\n\n\n","category":"method"},{"location":"internals/#LocalSearchSolvers._var_cost!-Tuple{LocalSearchSolvers._State, Any, Any}","page":"Internals","title":"LocalSearchSolvers._var_cost!","text":"_var_cost!(s::S, x, cost) where S <: Union{_State, AbstractSolver}\n\nSet the cost of variable x.\n\n\n\n\n\n","category":"method"},{"location":"internals/#LocalSearchSolvers._var_cost-Tuple{LocalSearchSolvers._State, Any}","page":"Internals","title":"LocalSearchSolvers._var_cost","text":"_var_cost(s::S, x) where S <: Union{_State, AbstractSolver}\n\nReturn the cost of variable x.\n\n\n\n\n\n","category":"method"},{"location":"internals/#LocalSearchSolvers._vars_costs!-Tuple{LocalSearchSolvers._State, Any}","page":"Internals","title":"LocalSearchSolvers._vars_costs!","text":"_vars_costs!(s::S, costs) where S <: Union{_State, AbstractSolver}\n\nSet the variables costs.\n\n\n\n\n\n","category":"method"},{"location":"internals/#LocalSearchSolvers._vars_costs-Tuple{LocalSearchSolvers._State}","page":"Internals","title":"LocalSearchSolvers._vars_costs","text":"_vars_costs(s::S) where S <: Union{_State, AbstractSolver}\n\nAccess the variables costs.\n\n\n\n\n\n","category":"method"},{"location":"internals/#LocalSearchSolvers._verbose-Tuple{Any, Any}","page":"Internals","title":"LocalSearchSolvers._verbose","text":"_verbose(settings, str)\n\nTemporary logging function. #TODO: use better log instead (LoggingExtra.jl)\n\n\n\n\n\n","category":"method"},{"location":"internals/#LocalSearchSolvers.decay_tabu!-Tuple{Any}","page":"Internals","title":"LocalSearchSolvers.decay_tabu!","text":"_decay_tabu!(s::S) where S <: Union{_State, AbstractSolver}\n\nDecay the tabu list.\n\n\n\n\n\n","category":"method"},{"location":"internals/#LocalSearchSolvers.decrease_tabu!-Tuple{Any, Any}","page":"Internals","title":"LocalSearchSolvers.decrease_tabu!","text":"_decrease_tabu!(s::S, x) where S <: Union{_State, AbstractSolver}\n\nDecrement the tabu value of variable x.\n\n\n\n\n\n","category":"method"},{"location":"internals/#LocalSearchSolvers.delete_tabu!-Tuple{Any, Any}","page":"Internals","title":"LocalSearchSolvers.delete_tabu!","text":"_delete_tabu!(s::S, x) where S <: Union{_State, AbstractSolver}\n\nDelete the tabu entry of variable x.\n\n\n\n\n\n","category":"method"},{"location":"internals/#LocalSearchSolvers.domain_size-Tuple{LocalSearchSolvers._Model, Any}","page":"Internals","title":"LocalSearchSolvers.domain_size","text":"domain_size(m::Model, x) = begin\n\nDOCSTRING\n\n\n\n\n\n","category":"method"},{"location":"internals/#LocalSearchSolvers.empty_tabu!-Tuple{Any}","page":"Internals","title":"LocalSearchSolvers.empty_tabu!","text":"_empty_tabu!(s::S) where S <: Union{_State, AbstractSolver}\n\nEmpty the tabu list.\n\n\n\n\n\n","category":"method"},{"location":"internals/#LocalSearchSolvers.get_kind-Tuple{LocalSearchSolvers._Model}","page":"Internals","title":"LocalSearchSolvers.get_kind","text":"get_kind(m::M) where M <: Union{Model, AbstractSolver}\n\nAccess the kind of m, such as :sudoku or :generic (default).\n\n\n\n\n\n","category":"method"},{"location":"internals/#LocalSearchSolvers.insert_tabu!-Tuple{Any, Any, Val{:tabu}}","page":"Internals","title":"LocalSearchSolvers.insert_tabu!","text":"_insert_tabu!(s::S, x, tabu_time) where S <: Union{_State, AbstractSolver}\n\nInsert the bariable x as tabu for tabu_time.\n\n\n\n\n\n","category":"method"},{"location":"internals/#LocalSearchSolvers.is_specialized-Tuple{LocalSearchSolvers._Model}","page":"Internals","title":"LocalSearchSolvers.is_specialized","text":"is_specialized(m::M) where M <: Union{Model, AbstractSolver}\n\nReturn true if the model is already specialized.\n\n\n\n\n\n","category":"method"},{"location":"internals/#LocalSearchSolvers.length_objs-Tuple{LocalSearchSolvers._Model}","page":"Internals","title":"LocalSearchSolvers.length_objs","text":"length_objs(m::M) where M <: Union{Model, AbstractSolver}\n\nReturn the number of objectives in m.\n\n\n\n\n\n","category":"method"},{"location":"internals/#LocalSearchSolvers.length_tabu-Tuple{Any}","page":"Internals","title":"LocalSearchSolvers.length_tabu","text":"_length_tabu!(s::S) where S <: Union{_State, AbstractSolver}\n\nReturn the length of the tabu list.\n\n\n\n\n\n","category":"method"},{"location":"internals/#LocalSearchSolvers.length_vars-Tuple{LocalSearchSolvers._Model}","page":"Internals","title":"LocalSearchSolvers.length_vars","text":"length_vars(m::M) where M <: Union{Model, AbstractSolver}\n\nReturn the number of variables in m.\n\n\n\n\n\n","category":"method"},{"location":"internals/#LocalSearchSolvers.tabu_list-Tuple{Any}","page":"Internals","title":"LocalSearchSolvers.tabu_list","text":"_tabu(s::S) where S <: Union{_State, AbstractSolver}\n\nAccess the list of tabu variables.\n\n\n\n\n\n","category":"method"},{"location":"internals/#LocalSearchSolvers.tabu_value-Tuple{Any, Any}","page":"Internals","title":"LocalSearchSolvers.tabu_value","text":"_tabu(s::S, x) where S <: Union{_State, AbstractSolver}\n\nReturn the tabu value of variable x.\n\n\n\n\n\n","category":"method"},{"location":"constraints/#Constraints","page":"Constraints","title":"Constraints","text":"","category":"section"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"In the LocalSearchSolvers.jl framework, a constraint can be define using either a concept (a predicate over a set of variables) or an error function. Additionally some constraints are already defined in  Constraints.jl.","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"As the recommended usage is through the CBLS.jl package and the JuMP.jl interface, we provide the related documentation here.","category":"page"},{"location":"constraints/#Predicates-and-Error-Functions","page":"Constraints","title":"Predicates and Error Functions","text":"","category":"section"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"CBLS.Predicate\nCBLS.Error","category":"page"},{"location":"constraints/#CBLS.Predicate","page":"Constraints","title":"CBLS.Predicate","text":"Predicate{F <: Function} <: JuMP.AbstractVectorSet\n\nAssuming X is a (collection of) variables, concept a boolean function over X, and that a model is defined. In JuMP syntax we can create a constraint based on concept as follows.\n\n@constraint(model, X in Predicate(concept))\n\n\n\n\n\n","category":"type"},{"location":"constraints/#CBLS.Error","page":"Constraints","title":"CBLS.Error","text":"Error{F <: Function} <: JuMP.AbstractVectorSet\n\nThe solver will compute a straightforward error function based on the concept. To run the solver efficiently, it is possible to provide an error function err instead of concept. err must return a nonnegative real number.\n\n@constraint(model, X in Error(err))\n\n\n\n\n\n","category":"type"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"Finally, one can compute the error function from a concept automatically using Interpretable Compositional Networks (ICN). Automatic computation through the CompositionalNetworks.jl package will soon be added within the JuMP syntax. In the mean time, please use this dependency directly.","category":"page"},{"location":"constraints/#Usual-Constraints","page":"Constraints","title":"Usual Constraints","text":"","category":"section"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"Some usual constraints are already available directly through JuMP syntax. Do not hesitate to file an issue to include more usual constraints.","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"CBLS.AllDifferent\nCBLS.AllEqual\nCBLS.AllEqualParam\nCBLS.AlwaysTrue\nCBLS.DistDifferent\nCBLS.Eq\nCBLS.Ordered","category":"page"},{"location":"constraints/#CBLS.AllDifferent","page":"Constraints","title":"CBLS.AllDifferent","text":"Global constraint ensuring that all the values of a given configuration are unique.\n\n@constraint(model, X in AllDifferent())\n\n\n\n\n\n","category":"type"},{"location":"constraints/#CBLS.AllEqual","page":"Constraints","title":"CBLS.AllEqual","text":"Global constraint ensuring that all the values of X are all equal.\n\n@constraint(model, X in AllEqual())\n\n\n\n\n\n","category":"type"},{"location":"constraints/#CBLS.AllEqualParam","page":"Constraints","title":"CBLS.AllEqualParam","text":"Global constraint ensuring that all the values of X are all equal to a given parameter param.\n\n@constraint(model, X in AllEqualParam(param))\n\n\n\n\n\n","category":"type"},{"location":"constraints/#CBLS.AlwaysTrue","page":"Constraints","title":"CBLS.AlwaysTrue","text":"Always return true. Mainly used for testing purpose.\n\n@constraint(model, X in AlwaysTrue())\n\n\n\n\n\n","category":"type"},{"location":"constraints/#CBLS.DistDifferent","page":"Constraints","title":"CBLS.DistDifferent","text":"Local constraint ensuring that, given a vector X of size 4, |X[1] - X[2]| ≠ |X[3] - X[4]|).\n\n@constraint(model, X in DistDifferent())\n\n\n\n\n\n","category":"type"},{"location":"constraints/#CBLS.Eq","page":"Constraints","title":"CBLS.Eq","text":"Equality between two variables.\n\n@constraint(model, X in Eq())\n\n\n\n\n\n","category":"type"},{"location":"constraints/#CBLS.Ordered","page":"Constraints","title":"CBLS.Ordered","text":"Global constraint ensuring that all the values of x are ordered.\n\n@constraint(model, X in Ordered())\n\n\n\n\n\n","category":"type"},{"location":"objectives/#Objectives","page":"Objectives","title":"Objectives","text":"","category":"section"},{"location":"objectives/","page":"Objectives","title":"Objectives","text":"Once a satisfying solution has been reached, the solver will try to minimize the provided objective function if any.","category":"page"},{"location":"objectives/","page":"Objectives","title":"Objectives","text":"As the recommended usage is through the CBLS.jl package and the JuMP.jl interface, we provide the related documentation here.","category":"page"},{"location":"objectives/#JuMP-syntax-(recommended)","page":"Objectives","title":"JuMP syntax (recommended)","text":"","category":"section"},{"location":"objectives/","page":"Objectives","title":"Objectives","text":"CBLS.ScalarFunction","category":"page"},{"location":"objectives/#CBLS.ScalarFunction","page":"Objectives","title":"CBLS.ScalarFunction","text":"ScalarFunction{F <: Function, V <: Union{Nothing, VOV}} <: MOI.AbstractScalarFunction\n\nA container to express any function with real value in JuMP syntax. Used with the @objective macro.\n\nArguments:\n\nf::F: function to be applied to X\nX::V: a subset of the variables of the model.\n\nGiven a model, and some (collection of) variables X to optimize. an objective function f can be added as follows. Note that only Min for minimization us currently defined. Max will come soon.\n\n# Applies to all variables in order of insertion.\n# Recommended only when the function argument order does not matter.\n@objective(model, ScalarFunction(f))\n\n# Generic use\n@objective(model, ScalarFunction(f, X))\n\n\n\n\n\n","category":"type"},{"location":"mincut/#Mincut","page":"Mincut","title":"Mincut","text":"","category":"section"},{"location":"mincut/","page":"Mincut","title":"Mincut","text":"Doc is still in construction. Please check mincut.jl in ConstraintModels.jl for details on the implementation.","category":"page"},{"location":"mincut/#Constructing-a-Mincut-model","page":"Mincut","title":"Constructing a Mincut model","text":"","category":"section"},{"location":"mincut/","page":"Mincut","title":"Mincut","text":"Note that the Interdiction Cut problem is NP-hard.","category":"page"},{"location":"mincut/","page":"Mincut","title":"Mincut","text":"ConstraintModels.mincut","category":"page"},{"location":"mincut/#ConstraintModels.mincut","page":"Mincut","title":"ConstraintModels.mincut","text":"mincut(graph::AbstractMatrix{T}; source::Int, sink::Int, interdiction::Int = 0) where T <: Number\n\nCompute the minimum cut of a graph.\n\nArguments:\n\ngraph: Any matrix <: AbstractMatrix that describes the capacities of the graph\nsource: Id of the source node; must be set\nsink: Id of the sink node; must be set\ninterdiction: indicates the number of forbidden links\n\n\n\n\n\n","category":"function"},{"location":"variables/#Variables","page":"Variables","title":"Variables","text":"","category":"section"},{"location":"variables/#Domains","page":"Variables","title":"Domains","text":"","category":"section"},{"location":"variables/","page":"Variables","title":"Variables","text":"In the LocalSearchSolvers.jl framework, a variable is mainly defined by its domain. A domain can be continuous, discrete, or mixed. All the domain implementation is available at ConstraintDomains.jl.","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"Currently, only discrete domains are available.","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"Domains can be used both statically or dynamically.","category":"page"},{"location":"variables/#JuMP-syntax-(recommended)","page":"Variables","title":"JuMP syntax (recommended)","text":"","category":"section"},{"location":"variables/","page":"Variables","title":"Variables","text":"# free variable named x\n@variable(model, x)\n\n# free variables in a X vector\n@variable(model, X[1:5])\n\n# variables with discrete domain 1:9 in a matrix M\n@variable(model, M[1:9,1:9] in DiscreteSet(1:9))","category":"page"},{"location":"quickstart/#Quick-Start-Guide","page":"Quick Start Guide","title":"Quick Start Guide","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start Guide","title":"Quick Start Guide","text":"This section introduce the main concepts of LocalSearchSolvers.jl. We model both a satisfaction and an optimization version of the Golomb Ruler problem. For this quick-start, we will use JuMP.jl.","category":"page"},{"location":"quickstart/#Golomb-Ruler","page":"Quick Start Guide","title":"Golomb Ruler","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start Guide","title":"Quick Start Guide","text":"From Wikipedia's English page.","category":"page"},{"location":"quickstart/","page":"Quick Start Guide","title":"Quick Start Guide","text":"In mathematics, a Golomb ruler is a set of marks at integer positions along an imaginary ruler such that no two pairs of marks are the same distance apart. The number of marks on the ruler is its order, and the largest distance between two of its marks is its length. Translation and reflection of a Golomb ruler are considered trivial, so the smallest mark is customarily put at 0 and the next mark at the smaller of its two possible values.","category":"page"},{"location":"quickstart/","page":"Quick Start Guide","title":"Quick Start Guide","text":"(Image: )","category":"page"},{"location":"quickstart/#Satisfaction-version","page":"Quick Start Guide","title":"Satisfaction version","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start Guide","title":"Quick Start Guide","text":"Given a number of marks n and a ruler length L, we can model our problem in Julia as easily as follows. First create an empty problem.","category":"page"},{"location":"quickstart/","page":"Quick Start Guide","title":"Quick Start Guide","text":"using CBLS # the JuMP interface for LocalSearchSolvers.jl\nusing JuMP\n\nmodel = Model(CBLS.Optimizer)","category":"page"},{"location":"quickstart/","page":"Quick Start Guide","title":"Quick Start Guide","text":"Then add n variables with domain 0:L.","category":"page"},{"location":"quickstart/","page":"Quick Start Guide","title":"Quick Start Guide","text":"n = 4 # marks\nL = n^2 # ruler length\n@variable(model, X[1:n], DiscreteSet(0:L))","category":"page"},{"location":"quickstart/","page":"Quick Start Guide","title":"Quick Start Guide","text":"Finally add the following constraints,","category":"page"},{"location":"quickstart/","page":"Quick Start Guide","title":"Quick Start Guide","text":"all marks have a different value\nmarks are ordered (optional)\nfinally, no two pairs of marks are the same distance apart","category":"page"},{"location":"quickstart/","page":"Quick Start Guide","title":"Quick Start Guide","text":"@constraint(model, X in AllDifferent()) # different marks\n@constraint(model, X in Ordered()) # for output layout, keep them ordered\n\n# No two pairs have the same length\nfor i in 1:(n - 1), j in (i + 1):n, k in i:(n - 1), l in (k + 1):n\n    (i, j) < (k, l) || continue\n    @constraint(model, [X[i], X[j], X[k], X[l]] in DistDifferent())\nend","category":"page"},{"location":"quickstart/#Optimization-version","page":"Quick Start Guide","title":"Optimization version","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start Guide","title":"Quick Start Guide","text":"A Golomb ruler can be either optimally dense (maximal m for a given L) or optimally short (minimal L for a given n). Until LocalSearchSolvers.jl implements dynamic problems, only optimal shortness is provided.","category":"page"},{"location":"quickstart/","page":"Quick Start Guide","title":"Quick Start Guide","text":"The model objective is then to minimize the maximum distance between the two extrema marks in the ruler. As the domains are positive, we can simply minimize the maximum value.","category":"page"},{"location":"quickstart/","page":"Quick Start Guide","title":"Quick Start Guide","text":"@objective(model, Min, ScalarFunction(maximum))","category":"page"},{"location":"quickstart/#Ruling-the-solver","page":"Quick Start Guide","title":"Ruling the solver","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start Guide","title":"Quick Start Guide","text":"For either version, the solver is built and run in a similar way. Please note that the satisfaction one will stop if a solution is found. The other will run until the maximum number of iteration is reached (1000 by default).","category":"page"},{"location":"quickstart/","page":"Quick Start Guide","title":"Quick Start Guide","text":"optimize!(model)","category":"page"},{"location":"quickstart/","page":"Quick Start Guide","title":"Quick Start Guide","text":"And finally retrieve the (best-known) solution info.","category":"page"},{"location":"quickstart/","page":"Quick Start Guide","title":"Quick Start Guide","text":"result = value.(X)\n@info \"Golomb marks: $result\"","category":"page"},{"location":"quickstart/","page":"Quick Start Guide","title":"Quick Start Guide","text":"Please note, that the Golomb Ruler is already implemented in the package as golomb(n::Int, L::Int=n^2).","category":"page"},{"location":"solving/#Modeling-and-solving","page":"Solving","title":"Modeling and solving","text":"","category":"section"},{"location":"solving/","page":"Solving","title":"Solving","text":"Ideally, given a problem, one just want to model and solve. That is what LocalSearchSolvers is aiming for. Here we only provide JuMP syntax.","category":"page"},{"location":"solving/#Model","page":"Solving","title":"Model","text":"","category":"section"},{"location":"solving/","page":"Solving","title":"Solving","text":"using CBLS, JuMP\n\nmodel = Model(CBLS.Optimizer) # CBLS is an exported alias of LocalSearchSolvers\n\n# add variables (cf Variables section)\n# add constraints (cf Constraints section)\n# add objective (cf Objectives section)","category":"page"},{"location":"solving/#Solver","page":"Solving","title":"Solver","text":"","category":"section"},{"location":"solving/","page":"Solving","title":"Solving","text":"# run the solver. If no objectives are provided, it will look for a satisfying solution and stop\noptimize!(model)\n\n# extract the values (assuming X, a (collection of) variable(s) is the target)\nsolution = value.(X)","category":"page"},{"location":"solving/#Solver-options","page":"Solving","title":"Solver options","text":"","category":"section"},{"location":"solving/","page":"Solving","title":"Solving","text":"LocalSearchSolvers.Options","category":"page"},{"location":"solving/#LocalSearchSolvers.Options","page":"Solving","title":"LocalSearchSolvers.Options","text":"Options()\n\nArguments:\n\ndynamic::Bool: is the model dynamic?\niteration::Union{Int, Float64}: limit on the number of iterations\nprint_level::Symbol: verbosity to choose among :silent, :minimal, :partial, :verbose\nsolutions::Int: number of solutions to return\nspecialize::Bool: should the types of the model be specialized or not. Usually yes for static problems. For dynamic in depends if the user intend to introduce new types. The specialized model is about 10% faster.\ntabu_time::Int: DESCRIPTION\ntabu_local::Int: DESCRIPTION\ntabu_delta::Float64: DESCRIPTION\nthreads::Int: Number of threads to use\ntime_limit::Float64: time limit in seconds\n`function Options(; dynamic = false, iteration = 10000, printlevel = :minimal, solutions = 1, specialize = !dynamic, tabutime = 0, tabulocal = 0, tabudelta = 0.0, threads = typemax(0), time_limit = Inf)\n\n# Setting options in JuMP syntax: print_level, time_limit, iteration\nmodel = Model(CBLS.Optimizer)\nset_optimizer_attribute(model, \"iteration\", 100)\nset_optimizer_attribute(model, \"print_level\", :verbose)\nset_time_limit_sec(model, 5.0)\n\n\n\n\n\n","category":"type"},{"location":"public/#Public","page":"Public","title":"Public","text":"","category":"section"},{"location":"public/","page":"Public","title":"Public","text":"Pages = [\"public.md\"]\nDepth = 5","category":"page"},{"location":"public/","page":"Public","title":"Public","text":"Modules = [LocalSearchSolvers]\nPrivate = false","category":"page"},{"location":"public/#LocalSearchSolvers._iteration!-Tuple{Any, Any}","page":"Public","title":"LocalSearchSolvers._iteration!","text":"_iteration!(options, iterations) = begin\n\nDOCSTRING\n\n\n\n\n\n","category":"method"},{"location":"public/#LocalSearchSolvers._iteration-Tuple{Any}","page":"Public","title":"LocalSearchSolvers._iteration","text":"_iteration(options) = begin\n\nDOCSTRING\n\n\n\n\n\n","category":"method"},{"location":"public/#LocalSearchSolvers._set_domain!-Tuple{LocalSearchSolvers._Model, Any, Any}","page":"Public","title":"LocalSearchSolvers._set_domain!","text":"_set_domain!(m::Model, x, values)\n\nDOCSTRING\n\nArguments:\n\nm: DESCRIPTION\nx: DESCRIPTION\nvalues: DESCRIPTION\n\n\n\n\n\n","category":"method"},{"location":"public/#LocalSearchSolvers._time_limit!-Tuple{Any, Any}","page":"Public","title":"LocalSearchSolvers._time_limit!","text":"_time_limit!(options, time::Time) = begin\n\nDOCSTRING\n\n\n\n\n\n","category":"method"},{"location":"public/#LocalSearchSolvers._time_limit-Tuple{Any}","page":"Public","title":"LocalSearchSolvers._time_limit","text":"_time_limit(options) = begin\n\nDOCSTRING\n\n\n\n\n\n","category":"method"},{"location":"public/#LocalSearchSolvers.add!-Tuple{LocalSearchSolvers._Model, LocalSearchSolvers.Variable}","page":"Public","title":"LocalSearchSolvers.add!","text":"add!(m::M, x) where M <: Union{Model, AbstractSolver}\nadd!(m::M, c) where M <: Union{Model, AbstractSolver}\nadd!(m::M, o) where M <: Union{Model, AbstractSolver}\n\nAdd a variable x, a constraint c, or an objective o to m.\n\n\n\n\n\n","category":"method"},{"location":"public/#LocalSearchSolvers.add_value!-Tuple{LocalSearchSolvers._Model, Any, Any}","page":"Public","title":"LocalSearchSolvers.add_value!","text":"add_value!(m::M, x, val) where M <: Union{Model, AbstractSolver}\n\nAdd val to x domain.\n\n\n\n\n\n","category":"method"},{"location":"public/#LocalSearchSolvers.add_var_to_cons!-Tuple{LocalSearchSolvers._Model, Any, Any}","page":"Public","title":"LocalSearchSolvers.add_var_to_cons!","text":"add_var_to_cons!(m::M, c, x) where M <: Union{Model, AbstractSolver}\n\nAdd x to the constraint c list of restricted variables.\n\n\n\n\n\n","category":"method"},{"location":"public/#LocalSearchSolvers.constraint!-Union{Tuple{V}, Tuple{LocalSearchSolvers._Model, Any, V}} where V<:(AbstractVector{var\"#s25\"} where var\"#s25\"<:Number)","page":"Public","title":"LocalSearchSolvers.constraint!","text":"constraint!(m::M, func, vars) where M <: Union{Model, AbstractSolver}\n\nAdd a constraint with an error function func defined over variables vars.\n\n\n\n\n\n","category":"method"},{"location":"public/#LocalSearchSolvers.constraint-Tuple{Any, Any}","page":"Public","title":"LocalSearchSolvers.constraint","text":"constraint(f, vars)\n\nDOCSTRING\n\n\n\n\n\n","category":"method"},{"location":"public/#LocalSearchSolvers.constriction-Tuple{LocalSearchSolvers._Model, Any}","page":"Public","title":"LocalSearchSolvers.constriction","text":"constriction(m::M, x) where M <: Union{Model, AbstractSolver}\n\nReturn the constriction of variable x.\n\n\n\n\n\n","category":"method"},{"location":"public/#LocalSearchSolvers.delete_value!-Tuple{LocalSearchSolvers._Model, Any, Any}","page":"Public","title":"LocalSearchSolvers.delete_value!","text":"delete_value(m::M, x, val) where M <: Union{Model, AbstractSolver}\n\nDelete val from x domain.\n\n\n\n\n\n","category":"method"},{"location":"public/#LocalSearchSolvers.delete_var_from_cons!-Tuple{LocalSearchSolvers._Model, Any, Any}","page":"Public","title":"LocalSearchSolvers.delete_var_from_cons!","text":"delete_var_from_cons(m::M, c, x) where M <: Union{Model, AbstractSolver}\n\nDelete x from the constraint c list of restricted variables.\n\n\n\n\n\n","category":"method"},{"location":"public/#LocalSearchSolvers.describe-Tuple{LocalSearchSolvers._Model}","page":"Public","title":"LocalSearchSolvers.describe","text":"describe(m::M) where M <: Union{Model, AbstractSolver}\n\nDescribe the model.\n\n\n\n\n\n","category":"method"},{"location":"public/#LocalSearchSolvers.draw-Tuple{LocalSearchSolvers._Model, Any}","page":"Public","title":"LocalSearchSolvers.draw","text":"draw(m::M, x) where M <: Union{Model, AbstractSolver}\n\nDraw a random value of x domain.\n\n\n\n\n\n","category":"method"},{"location":"public/#LocalSearchSolvers.get_cons_from_var-Tuple{LocalSearchSolvers._Model, Any}","page":"Public","title":"LocalSearchSolvers.get_cons_from_var","text":"get_cons_from_var(m::M, x) where M <: Union{Model, AbstractSolver}\n\nAccess the constraints restricting variable x.\n\n\n\n\n\n","category":"method"},{"location":"public/#LocalSearchSolvers.get_constraint-Tuple{LocalSearchSolvers._Model, Any}","page":"Public","title":"LocalSearchSolvers.get_constraint","text":"get_constraint(m::M, c) where M <: Union{Model, AbstractSolver}\n\nAccess the constraint c.\n\n\n\n\n\n","category":"method"},{"location":"public/#LocalSearchSolvers.get_constraints-Tuple{LocalSearchSolvers._Model}","page":"Public","title":"LocalSearchSolvers.get_constraints","text":"get_constraints(m::M) where M <: Union{Model, AbstractSolver}\n\nAccess the constraints of m.\n\n\n\n\n\n","category":"method"},{"location":"public/#LocalSearchSolvers.get_domain-Tuple{LocalSearchSolvers._Model, Any}","page":"Public","title":"LocalSearchSolvers.get_domain","text":"get_domain(m::M, x) where M <: Union{Model, AbstractSolver}\n\nAccess the domain of variable x.\n\n\n\n\n\n","category":"method"},{"location":"public/#LocalSearchSolvers.get_name-Tuple{LocalSearchSolvers._Model, Any}","page":"Public","title":"LocalSearchSolvers.get_name","text":"get_name(m::M, x) where M <: Union{Model, AbstractSolver}\n\nAccess the name of variable x.\n\n\n\n\n\n","category":"method"},{"location":"public/#LocalSearchSolvers.get_objective-Tuple{LocalSearchSolvers._Model, Any}","page":"Public","title":"LocalSearchSolvers.get_objective","text":"get_objective(m::M, o) where M <: Union{Model, AbstractSolver}\n\nAccess the objective o.\n\n\n\n\n\n","category":"method"},{"location":"public/#LocalSearchSolvers.get_objectives-Tuple{LocalSearchSolvers._Model}","page":"Public","title":"LocalSearchSolvers.get_objectives","text":"get_objectives(m::M) where M <: Union{Model, AbstractSolver}\n\nAccess the objectives of m.\n\n\n\n\n\n","category":"method"},{"location":"public/#LocalSearchSolvers.get_variable-Tuple{LocalSearchSolvers._Model, Any}","page":"Public","title":"LocalSearchSolvers.get_variable","text":"get_variable(m::M, x) where M <: Union{Model, AbstractSolver}\n\nAccess the variable x.\n\n\n\n\n\n","category":"method"},{"location":"public/#LocalSearchSolvers.get_variables-Tuple{LocalSearchSolvers._Model}","page":"Public","title":"LocalSearchSolvers.get_variables","text":"get_variables(m::M) where M <: Union{Model, AbstractSolver}\n\nAccess the variables of m.\n\n\n\n\n\n","category":"method"},{"location":"public/#LocalSearchSolvers.get_vars_from_cons-Tuple{LocalSearchSolvers._Model, Any}","page":"Public","title":"LocalSearchSolvers.get_vars_from_cons","text":"get_vars_from_cons(m::M, c) where M <: Union{Model, AbstractSolver}\n\nAccess the variables restricted by constraint c.\n\n\n\n\n\n","category":"method"},{"location":"public/#LocalSearchSolvers.is_sat-Tuple{LocalSearchSolvers._Model}","page":"Public","title":"LocalSearchSolvers.is_sat","text":"is_sat(m::M) where M <: Union{Model, AbstractSolver}\n\nReturn true if m is a satisfaction model.\n\n\n\n\n\n","category":"method"},{"location":"public/#LocalSearchSolvers.length_cons-Tuple{LocalSearchSolvers._Model, Any}","page":"Public","title":"LocalSearchSolvers.length_cons","text":"length_cons(m::M, c) where M <: Union{Model, AbstractSolver}\n\nReturn the length of constraint c.\n\n\n\n\n\n","category":"method"},{"location":"public/#LocalSearchSolvers.length_cons-Tuple{LocalSearchSolvers._Model}","page":"Public","title":"LocalSearchSolvers.length_cons","text":"length_cons(m::M) where M <: Union{Model, AbstractSolver}\n\nReturn the number of constraints in m.\n\n\n\n\n\n","category":"method"},{"location":"public/#LocalSearchSolvers.length_var-Tuple{LocalSearchSolvers._Model, Any}","page":"Public","title":"LocalSearchSolvers.length_var","text":"length_var(m::M, x) where M <: Union{Model, AbstractSolver}\n\nReturn the domain length of variable x.\n\n\n\n\n\n","category":"method"},{"location":"public/#LocalSearchSolvers.max_domains_size-Tuple{LocalSearchSolvers._Model, Any}","page":"Public","title":"LocalSearchSolvers.max_domains_size","text":"max_domains_size(m::Model, vars) = begin\n\nDOCSTRING\n\n\n\n\n\n","category":"method"},{"location":"public/#LocalSearchSolvers.model-Tuple{}","page":"Public","title":"LocalSearchSolvers.model","text":"model()\n\nConstruct a _Model, empty by default. It is recommended to add the constraints, variables, and objectives from an empty _Model. The following keyword arguments are available,\n\nvars=Dictionary{Int,Variable}(): collection of variables\ncons=Dictionary{Int,Constraint}(): collection of cosntraints\nobjs=Dictionary{Int,Objective}(): collection of objectives\nkind=:generic: the kind of problem modeled (useful for specialized methods such as pretty printing)\n\n\n\n\n\n","category":"method"},{"location":"public/#LocalSearchSolvers.o_dist_extrema-Tuple{Any}","page":"Public","title":"LocalSearchSolvers.o_dist_extrema","text":"dist_extrema(values::T...) where {T <: Number}\n\nComputes the distance between extrema in an ordered set.\n\n\n\n\n\n","category":"method"},{"location":"public/#LocalSearchSolvers.o_mincut-Tuple{Any, Any}","page":"Public","title":"LocalSearchSolvers.o_mincut","text":"o_mincut(graph, values; interdiction = 0)\n\nCompute the capacity of a cut (determined by the state of the solver) with a possible interdiction on the highest capacited links.\n\n\n\n\n\n","category":"method"},{"location":"public/#LocalSearchSolvers.objective!-Tuple{LocalSearchSolvers._Model, Any}","page":"Public","title":"LocalSearchSolvers.objective!","text":"objective!(m::M, func) where M <: Union{Model, AbstractSolver}\n\nAdd an objective evaluated by func.\n\n\n\n\n\n","category":"method"},{"location":"public/#LocalSearchSolvers.objective-Tuple{Any, Any}","page":"Public","title":"LocalSearchSolvers.objective","text":"objective(func, name)\n\nConstruct an objective with a function func that should be applied to a collection of variables.\n\n\n\n\n\n","category":"method"},{"location":"public/#LocalSearchSolvers.solution-Tuple{Any}","page":"Public","title":"LocalSearchSolvers.solution","text":"solution(s)\n\ntabu Return the only/best known solution of a satisfaction/optimization model.\n\n\n\n\n\n","category":"method"},{"location":"public/#LocalSearchSolvers.solve!-Tuple{Any}","page":"Public","title":"LocalSearchSolvers.solve!","text":"solve!(s; max_iteration=1000, verbose::Bool=false)\n\nRun the solver until a solution is found or max_iteration is reached. verbose=true will print out details of the run.\n\n# Simply run the solver with default max_iteration\nsolve!(s)\n\n# Run indefinitely the solver with verbose behavior.\nsolve!(s, max_iteration = Inf, verbose = true)\n\n\n\n\n\n","category":"method"},{"location":"public/#LocalSearchSolvers.solver","page":"Public","title":"LocalSearchSolvers.solver","text":"Solver{T}(m::Model; values::Dictionary{Int,T}=Dictionary{Int,T}()) where T <: Number\nSolver{T}(;\n    variables::Dictionary{Int,Variable}=Dictionary{Int,Variable}(),\n    constraints::Dictionary{Int,Constraint}=Dictionary{Int,Constraint}(),\n    objectives::Dictionary{Int,Objective}=Dictionary{Int,Objective}(),\n    values::Dictionary{Int,T}=Dictionary{Int,T}(),\n) where T <: Number\n\nConstructor for a solver. Optional starting values can be provided.\n\n# Model a sudoku model of size 4×4\nm = sudoku(2)\n\n# Create a solver instance with variables taking integral values\ns = Solver{Int}(m)\n\n# Solver with an empty model to be filled later and expected Float64 values\ns = Solver{Float64}()\n\n# Construct a solver from a sets of constraints, objectives, and variables.\ns = Solver{Int}(\n    variables = get_constraints(m),\n    constraints = get_constraints(m),\n    objectives = get_objectives(m)\n)\n\n\n\n\n\n","category":"function"},{"location":"public/#LocalSearchSolvers.specialize!-Tuple{Any}","page":"Public","title":"LocalSearchSolvers.specialize!","text":"specialize!(s) = begin\n\nDOCSTRING\n\n\n\n\n\n","category":"method"},{"location":"public/#LocalSearchSolvers.specialize-Tuple{LocalSearchSolvers._Model}","page":"Public","title":"LocalSearchSolvers.specialize","text":"specialize(m::M) where M <: Union{Model, AbstractSolver}\n\nSpecialize the structure of a model to avoid dynamic type attribution at runtime.\n\n\n\n\n\n","category":"method"},{"location":"public/#LocalSearchSolvers.variable!","page":"Public","title":"LocalSearchSolvers.variable!","text":"variable!(m::M, d) where M <: Union{Model, AbstractSolver}\n\nAdd a variable with domain d to m.\n\n\n\n\n\n","category":"function"},{"location":"public/#LocalSearchSolvers.variable-Tuple{}","page":"Public","title":"LocalSearchSolvers.variable","text":"variable(values::AbstractVector{T}, name::AbstractString; domain = :set) where T <: Number\nvariable(domain::AbstractDomain, name::AbstractString) where D <: AbstractDomain\n\nConstruct a variable with discrete domain. See the domain method for other options.\n\nd = domain([1,2,3,4], types = :indices)\nx1 = variable(d, \"x1\")\nx2 = variable([-89,56,28], \"x2\", domain = :indices)\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = LocalSearchSolvers","category":"page"},{"location":"#Constraint-Based-Local-Search-Framework","page":"Home","title":"Constraint-Based Local Search Framework","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The LocalSearchSolvers.jl framework proposes sets of technical components of Constraint-Based Local Search (CBLS) solvers and combine them in various ways. Make your own CBLS solver!","category":"page"},{"location":"","page":"Home","title":"Home","text":"<!– TODO: what is a CBLS solver etc. –>","category":"page"},{"location":"","page":"Home","title":"Home","text":"A higher-level JuMP interface is available as CBLS.jl and is the recommended way to use this package. A set of examples is available within ConstraintModels.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"#Dependencies","page":"Home","title":"Dependencies","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package makes use of several dependencies from the JuliaConstraints GitHub org:","category":"page"},{"location":"","page":"Home","title":"Home","text":"ConstraintDomains.jl: a domains back-end package for all JuliaConstraints front packages\nConstraints.jl: a constraints back-end package for all JuliaConstraints front packages\nCompositionalNetworks.jl: a module to learn error functions automatically given a concept\nGaramon.jl (incoming): geometrical constraints","category":"page"},{"location":"","page":"Home","title":"Home","text":"It also relies on great packages from the julialang ecosystem, among others,","category":"page"},{"location":"","page":"Home","title":"Home","text":"ModernGraphs.jl (incoming): a dynamic multilayer framework for complex graphs which allows a fine exploration of entangled neighborhoods","category":"page"},{"location":"#Related-packages","page":"Home","title":"Related packages","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"JuMP.jl: a rich interface for optimization solvers\nCBLS.jl: the actual interface with JuMP for LocalSearchSolvers.jl\nConstraintModels.jl: a dataset of models for Constraint Programming\nCOPInstances.jl (incoming): a package to store, download, and generate combinatorial optimization instances","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Wanted features list:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Strategies\n[ ] Move: local move, permutation between n variables\n[ ] Neighbor: simple or multiplexed neighborhood, dimension/depth\n[ ] Objective(s): single/multiple objectives, Pareto, etc.\n[ ] Parallel: distributed and multi-threaded, HPC clusters\n[ ] Perturbation: dynamic, restart, pool of solutions\n[ ] Portfolio: portfolio of solvers, partition in sub-problems\n[ ] Restart\n[x] restart sequence\n[ ] partial/probabilistic restart (in coordination with perturbation strategies)\n[ ] Selection of variables: roulette selection, multi-variables, meta-variables (cf subproblem)\n[ ] Solution(s): management of pool, best versus diverse\nTabu\n[x] No Tabu\n[x] Weak-tabu\n[x] Keen-tabu\nTermination: when, why, how, interactive, results storage (remote)\nFeatured strategies\n[ ] Adaptive search\n[ ] Extremal optimization\nOthers\n[ ] Resolution of problems\n[x] SATisfaction\n[x] OPTimisation (single-objective)\n[ ] OPTimisation (multiple-objective)\n[ ] Dynamic problems\n[ ] Domains\n[x] Discrete domains (any type of numbers)\n[x] Continuous domains\n[ ] Arbitrary Objects such as physical ones\n[ ] Domain Specific Languages (DSL)\n[x] Straight Julia :raw\n[x] JuMPish | MathOptInterface.jl\n[ ] MiniZinc\n[ ] OR-tools ?\n[ ] Learning settings (To be incorporated in MetaStrategist.jl)\n[x] Compositional Networks (error functions, cost functions)\n[ ] Reinforcement learning for above mentioned learning features\n[ ] Automatic benchmarking and learning from all the possible parameter combination (instance, model, solver, size, restart, hardware, etc.)","category":"page"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Contributions to this package are more than welcome and can be arbitrarily, and not exhaustively, split as follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"All features mentioned above\nAdding new constraints and symmetries\nAdding new problems and instances\nAdding new ICNs to learn error of existing constraints\nCreating other compositional networks which target other kind of constraints\nJust making stuff better, faster, user-friendlier, etc.","category":"page"},{"location":"#Contact","page":"Home","title":"Contact","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Do not hesitate to contact me (@azzaare) or other members of JuliaConstraints on GitHub (file an issue), the julialang Discourse forum, the julialang Slack workspace, the julialang Zulip server (Constraint Programming stream), or the Humans of Julia Humans-of-Julia discord server(julia-constraint channel).","category":"page"}]
}
